'use strict';
import * as vscode from 'vscode';
import * as fs from 'fs';
import { executeCommand, checkOutput } from './processtool';

var extensionPath: string

async function getVarsInfo(): Promise<Map<String, Array<String>>> {
    let out = await checkOutput(["make", "-C", vscode.workspace.rootPath, "printvars"]);
    var vars = new Map<String, Array<String>>();
    for (let line of out.split("\n")) {
        if (line.startsWith("VARS:")) {
            for (let expr of line.split(":").splice(1)) {
                let exprS = expr.split("=", 2);
                if (exprS.length != 2) continue;
                if (!(exprS[0] in vars)) vars[exprS[0]] = [];
                vars[exprS[0]].push(exprS[1]);
            }
        }
    }
    return vars;
}

async function reloadProjectInfo(context: vscode.ExtensionContext) {
    if (!fs.existsSync(vscode.workspace.rootPath + "/CMakeCache.txt")) {
        await executeCommand("Husarion: initialize build",
            ["cmake", ".",
                "-DPORT=stm32",
                "-DBOARD_VERSION=1.0.0",
                "-DBOARD_TYPE=core2",
                "-DHFRAMEWORK_PATH=" + extensionPath + "/sdk"], { cwd: vscode.workspace.rootPath });
    } else {
        await executeCommand("Husarion: reload build", ["cmake", "."], { cwd: vscode.workspace.rootPath }, true);
    }

    let vars = await getVarsInfo();
    let vscodeDir = vscode.workspace.rootPath + "/.vscode";
    if (!fs.existsSync(vscodeDir))
        fs.mkdirSync(vscodeDir);

    fs.writeFileSync(vscodeDir + "/c_cpp_properties.json", JSON.stringify({
        "_comment": "Autogenerated by Husarion plugin",
        "configurations": [
            {
                "name": "Husarion",
                "includePath": vars["include"].concat(["/usr/include"]), // TODO: windows
                "browse": {
                    "limitSymbolsToIncludedHeaders": true,
                    "databaseFilename": ""
                }
            }
        ]
    }));

    let problemMatcher = {
        "owner": "cpp",
        "fileLocation": "absolute",
        "pattern": {
            "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",
            "file": 1,
            "line": 2,
            "column": 3,
            "severity": 4,
            "message": 5
        }
    };

    fs.writeFileSync(vscodeDir + "/tasks.json", JSON.stringify({
        "_comment": "Autogenerated by Husarion plugin",
        "version": "0.1.0",
        "command": "make",
        "tasks": [
            {
                "taskName": "build",
                "suppressTaskName": true,
                "args": [],
                "isBuildCommand": true,
                "showOutput": "silent",
                "problemMatcher": problemMatcher
            },
            {
                "taskName": "flash",
                "args": [],
                "problemMatcher": problemMatcher
            }
        ]
    }));

    let debuggerInfo = {
        "MIMode": "gdb"
    };

    fs.writeFileSync(vscodeDir + "/launch.json", JSON.stringify({
        "version": "0.2.0",
        "configurations": [
            {
                "name": "Flash to CORE2",
                "type": "cppdbg",
                "request": "launch",
                "program": vars["main_executable"][0] + ".elf",
                "args": [],
                "stopAtEntry": false,
                "cwd": "${workspaceRoot}",
                "env": {
                    "GDBWRAPPER_FLASH": "true",   
                },
                "externalConsole": true,
                "linux": debuggerInfo,
                "windows": debuggerInfo,
            }, // TODO: request "attach"
        ]
    }))
}

async function setupProject(context: vscode.ExtensionContext) {
    console.log(vscode.workspace.rootPath);
    if (!fs.existsSync(vscode.workspace.rootPath + "/main.cpp")) {
        fs.writeFileSync(vscode.workspace.rootPath + "/main.cpp", fs.readFileSync(extensionPath + "/sdk/project_template/main.cpp"))
    }

    fs.writeFileSync(vscode.workspace.rootPath + "/CMakeLists.txt", fs.readFileSync(extensionPath + "/sdk/project_template/CMakeLists.txt"));

    const gitignore = "# These file are generated by Husarion VSCode extension\n\n" +
        "/.vscode/c_cpp_properties.json\n/.vscode/tasks.json\n/.vscode/launch.json\n/CMakeCache.txt\n/CMakeFiles\nMakefile\n*.hex\n*.elf\n*.bin\ncmake_install.cmake\n";
    if (fs.existsSync(vscode.workspace.rootPath + "/.gitignore")) {
        fs.appendFileSync(vscode.workspace.rootPath + "/.gitignore", gitignore);
    } else {
        fs.writeFileSync(vscode.workspace.rootPath + "/.gitignore", gitignore);
    }

    await reloadProjectInfo(context);
}

async function reconfigure(name: string, value: string) {
    await executeCommand("Husarion: reconfigure", ["cmake", ".", "-D" + name + "=" + value], { cwd: vscode.workspace.rootPath });
}

async function changeHusarionProjectVariable(context: vscode.ExtensionContext) {
    let resp = await vscode.window.showQuickPick([
        { description: "SDK path", label: "HFRAMEWORK_PATH" },
        { description: "Target board type", label: "BOARD_TYPE" },
        { description: "Target board version", label: "BOARD_VERSION" },
        { description: "Debug information", label: "DEBUG" },
    ])
    if (!resp) return;
    if (resp.label == "HFRAMEWORK_PATH") {
        await reconfigure(resp.label, await vscode.window.showInputBox({ "prompt": "Path to hFramework" }));
    } else if (resp.label == "BOARD_TYPE") {
        await reconfigure(resp.label, await vscode.window.showQuickPick(["core2", "robocore"]));
    } else if (resp.label == "BOARD_VERSION") {
        await reconfigure(resp.label, await vscode.window.showQuickPick(["1.0.0"]));
    } else if (resp.label == "DEBUG") {
        await reconfigure(resp.label, await vscode.window.showQuickPick(["true", "false"]));
    }
    await reloadProjectInfo(context);
}

export async function activate(context: vscode.ExtensionContext) {
    const extension = vscode.extensions.getExtension("husarion.husarion");
    extensionPath = extension.extensionPath;

    context.subscriptions.push(vscode.commands.registerCommand('extension.createHusarionProject', async () => {
        var cmakeListsPath = vscode.workspace.rootPath + '/CMakeLists.txt';

        if (fs.existsSync(cmakeListsPath)) {
            vscode.window.showErrorMessage("CMakeLists.txt already exists in current workspace.");
            await vscode.commands.executeCommand("vscode.open", vscode.Uri.parse("file://" + cmakeListsPath));
            await reloadProjectInfo(context);
            return;
        }

        await setupProject(context);
    }));

    context.subscriptions.push(vscode.commands.registerCommand('extension.reloadHusarionProject', () => reloadProjectInfo(context)));
    context.subscriptions.push(vscode.commands.registerCommand('extension.changeHusarionProjectVariable', () => changeHusarionProjectVariable(context)));
    context.subscriptions.push(vscode.commands.registerCommand('extension.flashCORE2', () => {
        executeCommand("Flash", ["make", "flash"], { cwd: vscode.workspace.rootPath }).catch((err) => { });
    }));

    if (fs.existsSync(vscode.workspace.rootPath + '/CMakeLists.txt')) {
        reloadProjectInfo(context);
    }
}

// this method is called when your extension is deactivated
export function deactivate() {
}